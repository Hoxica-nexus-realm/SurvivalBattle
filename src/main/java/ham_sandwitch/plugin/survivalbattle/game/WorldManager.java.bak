package ham_sandwitch.plugin.survivalbattle.game;

import java.io.File;
import java.util.Random;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.lang.reflect.Method;

import org.bukkit.Bukkit;
import org.bukkit.Difficulty;
import org.bukkit.GameRule;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.WorldBorder;
import org.bukkit.WorldCreator;
import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;

public class WorldManager {
    
    private final JavaPlugin plugin;
    private World battleWorld;
    
    // 収集フェーズのデフォルト大幅に拡張
    private static final int COLLECTION_BORDER_SIZE = 100000;
    // PVP フェーズの初期ボーダー（デフォルト）
    private static final int DEFAULT_PVP_INITIAL_BORDER = 150;
    private static final double BORDER_DAMAGE = 0.5;
    
    public WorldManager(JavaPlugin plugin) {
        this.plugin = plugin;
    }

    /**
     * 収集フェーズ開始時のワールドボーダー設定（設定値に基づく）
     */
    public void setupCollectionPhaseBorder() {
        int size = plugin.getConfig().getInt("game.collection_border_size", COLLECTION_BORDER_SIZE);
        setCollectionBorder(size);
    }

    /**
     * PVPフェーズ開始時のワールドボーダー設定（設定値に基づく）
     */
    public void setupPVPPhaseBorder() {
        double size = plugin.getConfig().getDouble("game.pvp_initial_border", DEFAULT_PVP_INITIAL_BORDER);
        setPvpBorder(size);
    }
    
    /**
     * 新しいバトルワールドを生成
     */
    public boolean createBattleWorld() {
        deleteBattleWorld();
        
        WorldCreator wc = new WorldCreator("survivalbattle_battle_" + System.currentTimeMillis());
        wc.environment(World.Environment.NORMAL);
        wc.seed(new Random().nextLong());
        this.battleWorld = wc.createWorld();
        
        if (this.battleWorld == null) {
            return false;
        }
        
        setupBattleWorld();
        return true;
    }
    
    /**
     * バトルワールドの初期設定
     */
    private void setupBattleWorld() {
        if (battleWorld == null) return;
        
        battleWorld.setTime(0);
        battleWorld.setDifficulty(Difficulty.NORMAL);
        
        // ゲームルール設定
        battleWorld.setGameRule(GameRule.DO_DAYLIGHT_CYCLE, true);
        battleWorld.setGameRule(GameRule.DO_MOB_SPAWNING, false);  // ★ MOB 無効化
        battleWorld.setGameRule(GameRule.KEEP_INVENTORY, false);
        battleWorld.setGameRule(GameRule.ANNOUNCE_ADVANCEMENTS, false);
        battleWorld.setGameRule(GameRule.DO_FIRE_TICK, true);
        battleWorld.setGameRule(GameRule.DO_WEATHER_CYCLE, false);  // ★ 天候無効化
        battleWorld.setGameRule(GameRule.DO_MOB_LOOT, true);
        battleWorld.setGameRule(GameRule.DO_TILE_DROPS, true);
        battleWorld.setGameRule(GameRule.RANDOM_TICK_SPEED, 3);

        WorldBorder border = battleWorld.getWorldBorder();
        border.setCenter(0, 0);
        border.setSize(COLLECTION_BORDER_SIZE);
        border.setWarningDistance(10);
        border.setDamageAmount(BORDER_DAMAGE);
        
        plugin.getLogger().info("Battle world created: " + battleWorld.getName());

        // WorldGuard の保護があれば自動で解除を試みる
        try {
            clearWorldGuardRegions(battleWorld);
        } catch (Exception e) {
            plugin.getLogger().warning("Failed to clear WorldGuard protections: " + e.getMessage());
        }
    }

    /**
     * WorldGuard の保護（リージョン）を自動で解除する。WorldGuard が存在しない場合は何もしない。
     * この実装は WorldGuard の複数バージョンを想定し、リフレクションで安全に呼び出します。
     */
    @SuppressWarnings({"unchecked","rawtypes"})
    private void clearWorldGuardRegions(World world) {
        if (world == null) return;
        if (Bukkit.getPluginManager().getPlugin("WorldGuard") == null) {
            return; // WorldGuard が無ければ何もしない
        }

        // まずは古い/一般的な Bukkit プラグインラッパー経由のAPIを試す
        try {
            Object wgPlugin = Bukkit.getPluginManager().getPlugin("WorldGuard");
            Class<?> wgPluginClass = Class.forName("com.sk89q.worldguard.bukkit.WorldGuardPlugin");
            Method getRegionManager = wgPluginClass.getMethod("getRegionManager", org.bukkit.World.class);
            Object regionManager = getRegionManager.invoke(wgPlugin, world);
            if (regionManager != null) {
                Method getRegions = regionManager.getClass().getMethod("getRegions");
                Object regionsObj = getRegions.invoke(regionManager);
                if (regionsObj instanceof Map) {
                    Map regions = (Map) regionsObj;
                    List keys = new ArrayList(regions.keySet());
                    Method removeRegion = regionManager.getClass().getMethod("removeRegion", String.class);
                    for (Object k : keys) {
                        try {
                            removeRegion.invoke(regionManager, k.toString());
                        } catch (Exception e) {
                            plugin.getLogger().warning("Failed to remove WorldGuard region " + k + ": " + e.getMessage());
                        }
                    }
                    plugin.getLogger().info("WorldGuard regions cleared for world: " + world.getName());
                    return;
                }
            }
        } catch (ClassNotFoundException cnfe) {
            // クラスが無ければ次の方法を試す
        } catch (Exception e) {
            plugin.getLogger().warning("Failed to clear WorldGuard regions via legacy API: " + e.getMessage());
        }

        // 近年の WorldGuard/WorldEdit の分離されたAPI（WorldGuard.getInstance() 経由）を試す
        try {
            Class<?> wgClass = Class.forName("com.sk89q.worldguard.WorldGuard");
            Object wgInst = wgClass.getMethod("getInstance").invoke(null);
            Object platform = wgClass.getMethod("getPlatform").invoke(wgInst);
            Object container = platform.getClass().getMethod("getRegionContainer").invoke(platform);

            // WorldEdit の BukkitAdapter を使って org.bukkit.World -> WorldEdit world に変換
            Class<?> bukkitAdapterClass = Class.forName("com.sk89q.worldedit.bukkit.BukkitAdapter");
            Method adapt = bukkitAdapterClass.getMethod("adapt", org.bukkit.World.class);
            Object weWorld = adapt.invoke(null, world);

            Method getMethod = container.getClass().getMethod("get", weWorld.getClass());
            Object regionManager = getMethod.invoke(container, weWorld);
            if (regionManager != null) {
                Method getRegions = regionManager.getClass().getMethod("getRegions");
                Object regionsObj = getRegions.invoke(regionManager);
                if (regionsObj instanceof Map) {
                    Map regions = (Map) regionsObj;
                    List keys = new ArrayList(regions.keySet());
                    Method removeRegion = regionManager.getClass().getMethod("removeRegion", String.class);
                    for (Object k : keys) {
                        try {
                            removeRegion.invoke(regionManager, k.toString());
                        } catch (Exception e) {
                            plugin.getLogger().warning("Failed to remove WorldGuard region " + k + ": " + e.getMessage());
                        }
                    }
                    plugin.getLogger().info("WorldGuard regions cleared for world (modern API): " + world.getName());
                    return;
                }
            }
        } catch (ClassNotFoundException cnfe) {
            plugin.getLogger().info("WorldGuard/WorldEdit classes not found; skipping WG clear.");
        } catch (Exception e) {
            plugin.getLogger().warning("Failed to clear WorldGuard regions via modern API: " + e.getMessage());
        }
    }
    
    /**
     * PVPフェーズ用にボーダーを初期サイズに設定（可変版）
     */
    public void setPvpBorder(double size) {
        if (battleWorld == null) return;
        
        WorldBorder border = battleWorld.getWorldBorder();
        border.setCenter(0, 0);
        border.setSize(size);
        
        plugin.getLogger().info("PVP border set: " + size);
    }

    /**
     * 収集フェーズ用のボーダーサイズを設定
     */
    public void setCollectionBorder(int size) {
        if (battleWorld == null) return;
        WorldBorder border = battleWorld.getWorldBorder();
        border.setCenter(0, 0);
        border.setSize(size);
        plugin.getLogger().info("Collection border set: " + size);
    }
    
    /**
     * ワールドボーダーを縮小開始（最終サイズと秒数を指定）
     */
    public void startBorderShrink(double finalSize, int durationSeconds) {
        if (battleWorld == null) return;
        
        WorldBorder border = battleWorld.getWorldBorder();
        // 設定されている現在サイズから finalSize に duration で縮小
        border.setSize(finalSize, durationSeconds);
        
        plugin.getLogger().info("Border shrinking to " + finalSize + " over " + durationSeconds + "s");
    }

    /**
     * 現在のワールドボーダー内からランダムに安全位置を見つける
     */
    public Location findRandomLocationInBorder(int tries, int minY) {
        if (battleWorld == null) return null;
        WorldBorder border = battleWorld.getWorldBorder();
        double half = Math.max(1.0, border.getSize() / 2.0 - 5.0);
        Random rnd = new Random();
        for (int i = 0; i < Math.max(1, tries); i++) {
            double angle = rnd.nextDouble() * Math.PI * 2.0;
            double r = rnd.nextDouble() * half;
            int x = (int) Math.round(border.getCenter().getX() + Math.cos(angle) * r);
            int z = (int) Math.round(border.getCenter().getZ() + Math.sin(angle) * r);
            Location guess = new Location(battleWorld, x + 0.5, Math.max(minY, 90), z + 0.5);
            Location safe = TeleportUtil.findSafeLocation(guess);
            if (safe != null) return safe;
        }
        return getBattleSpawnLocation();
    }
    
    /**
     * バトルワールドのスポーン地点を取得
     */
    public Location getBattleSpawnLocation() {
        if (battleWorld == null) return null;
        
        Location spawn = battleWorld.getSpawnLocation().clone();
        spawn.add(0.5, 0.5, 0.5);
        spawn.add(0.5, 1.0, 0.5);
        return TeleportUtil.findSafeLocation(spawn);
    }
    
    /**
     * 中央から半径50以内のランダムな安全位置を取得
     */
    public Location getRandomSafeLocation() {
        if (battleWorld == null) return null;
        
        Random random = new Random();
        int maxAttempts = 50;
        
        for (int i = 0; i < maxAttempts; i++) {
            double angle = random.nextDouble() * 2 * Math.PI;
            double distance = random.nextDouble() * 50;
            
            int x = (int) (distance * Math.cos(angle));
            int z = (int) (distance * Math.sin(angle));
            
            Location loc = new Location(battleWorld, x + 0.5, 100, z + 0.5);
            Location safeLoc = TeleportUtil.findSafeLocation(loc);
            
            if (safeLoc != null) {
                return safeLoc;
            }
        }
        
        Location fallback = new Location(battleWorld, 0.5, 100, 0.5);
        return TeleportUtil.findSafeLocation(fallback);
    }
    
    /**
     * バトルワールドをアンロードし、フォルダを削除
     */
    public void deleteBattleWorld() {
        if (battleWorld == null) return;
        
        String worldName = battleWorld.getName();
        for (Player p : battleWorld.getPlayers()) {
            p.teleport(Bukkit.getWorlds().get(0).getSpawnLocation());
        }

        // 保存してからアンロードする。worldFolder を先に取得しておく。
        File worldFolder = battleWorld.getWorldFolder();

        // try to save and unload the world cleanly
        boolean unloaded = Bukkit.unloadWorld(battleWorld, true);
        if (unloaded) {
            // clear reference immediately to avoid races
            battleWorld = null;

            // 削除は非同期で行い、結果をメインスレッドでログする
            final File folderToDelete = worldFolder;
            // Schedule deletion attempts with retries (async). 初回遅延を短めに設定
            scheduleFolderDeletion(folderToDelete, 3, 40L, worldName);
        } else {
            plugin.getLogger().warning("Failed to unload world: " + worldName);
        }
    }
    /**
     * フォルダを非同期で再帰的に削除するヘルパー。
     * 成功したかどうかを返す。
     */
    private boolean deleteFolderAsync(File folder) {
        if (folder == null) return true;
        boolean allDeleted = true;

        File[] files = folder.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    boolean child = deleteFolderAsync(file);
                    if (!child) allDeleted = false;
                } else {
                    try {
                        if (!file.delete()) {
                            allDeleted = false;
                        }
                    } catch (Exception e) {
                        allDeleted = false;
                    }
                }
            }
        }

        try {
            if (!folder.delete()) {
                allDeleted = false;
            }
        } catch (Exception e) {
            allDeleted = false;
        }

        return allDeleted;
    }

    /**
     * 試行回数つきでフォルダ削除をスケジュールする。
     * このメソッドはメインスレッドから呼ぶ。
     */
    private void scheduleFolderDeletion(File folder, int attempts, long delayTicks, String worldName) {
        if (folder == null) {
            Bukkit.getScheduler().runTask(plugin, () -> plugin.getLogger().info("No world folder to delete: " + worldName));
            return;
        }

        Bukkit.getScheduler().runTaskLaterAsynchronously(plugin, new Runnable() {
            int remaining = attempts;

            @Override
            public void run() {
                boolean ok = deleteFolderAsync(folder);
                if (ok) {
                    Bukkit.getScheduler().runTask(plugin, () -> plugin.getLogger().info("World folder deleted: " + worldName));
                    return;
                }

                remaining--;
                if (remaining <= 0) {
                    Bukkit.getScheduler().runTask(plugin, () -> plugin.getLogger().warning("Failed to delete world folder after retries: " + worldName));
                    return;
                }

                // schedule another attempt with increased delay
                long nextDelay = Math.max(20L, delayTicks * 2);
                Bukkit.getScheduler().runTaskLaterAsynchronously(plugin, this, nextDelay);
            }
        }, delayTicks);
    }
    
    public World getBattleWorld() {
        return battleWorld;
    }
    
    public boolean hasBattleWorld() {
        return battleWorld != null;
    }
}
